{
    "collab_server" : "",
    "contents" : "if (!('corrplot' %in% installed.packages())) install.packages('corrplot') else 0\nlibrary(corrplot)\n\nbeer2 <- read.csv('recipes-2.csv')\n\n# checks correlation betweehn Orig_Gravity, Final_Gravity, ABV, IBU, SRM\ncorrplot.mixed(cor(beer[,2:6]))\n# correlation between Orig_Gravity and ABV is very high - can ignore ABV\n\n# Creates new varialbes for each unqiue value under fermentable# \n# gets all the unique values for the fermentable fields\nfermentables <- unique(c(as.character(beer$Fermentable1), \n         as.character(beer$Fermentable2), \n         as.character(beer$Fermentable3), \n         as.character(beer$Fermentable4)))\n\n# gets rid of the pesky ''\nfermentables <- fermentables[!(fermentables == '')]\n\n# assigns the amounts to the appropiate fields \nfor (i in as.character(fermentables)) {\n  nc <- rep(0, nrow(beer))\n  for (j in 8:11 ) {\n    nc[beer[ ,j] == i] <- beer[beer[ ,j] == i,j+4]\n    beer[ ,eval(i)] <- nc\n  }\n}\n\n# rinse & repeat for FirstWortHops\nfirstwort <- unique(c(as.character(beer$FirstWortHops1), \n                         as.character(beer$FirstWortHops2)))\n\nfirstwort <- firstwort[!(firstwort == '')]\n\n# assigns the amounts to the appropiate fields \nfor (i in as.character(firstwort)) {\n  nc <- rep(0, nrow(beer))\n  for (j in 16:17 ) {\n    nc[beer[ ,j] == i] <- beer[beer[ ,j] == i,j+2]\n    beer[ ,eval(i)] <- nc\n  }\n}\n\n# The boilhops fields are tricky... Think I'm going to replace the gaps with 'None' and the NAs with 0\nboilfields <- c('BoilHops1', 'BoilHops2', 'BoilHops3', 'BoilHops4')\nfor (i in 1:4) {\n  levels(beer[,eval(boilfields[i])]) <- \n    c(levels(beer[,eval(boilfields[i])]), 'None')\n  beer[beer[,eval(boilfields[i])] == '',eval(boilfields[i])] <- 'None'\n}\n\nboilnumfields <- c('BH_Amount1', 'BH_Amount2', 'BH_Amount3', 'BH_Amount4', \n                   'Boil_Time1', 'Boil_Time2', 'Boil_Time3', 'Boil_Time4')\nfor (i in 1:length(boilnumfields)) {\n  beer[, eval(boilnumfields[i])][is.na(beer[, eval(boilnumfields[i])])] <- 0\n}\n\n\n# Going to do the same with DryHops what I did the to the Fermentable fields, first have to convert the Time to numeric values\nbeer$DryHop_Time1 <- \n  as.numeric(sapply(beer$DryHop_Time1, function(x) gsub(' Days', '', x)))\n\nbeer$DryHop_Time2 <- \n  as.numeric(sapply(beer$DryHop_Time2, function(x) gsub(' Days', '', x)))\n\nDryHop <- unique(c(as.character(beer$DryHop1), \n                      as.character(beer$DryHop2)))\n\nDryHop <- DryHop[!(DryHop == '')]\n\n# assigns the amounts to the appropiate fields \nfor (i in as.character(DryHop)) {\n  nc <- rep(0, nrow(beer))\n  for (j in 32:33 ) {\n    nc[beer[ ,j] == i] <- beer[beer[ ,j] == i,j+2]\n    beer[ ,eval(i)] <- nc\n  }\n}\n\n\n# Mash.... fill the Mashtype gaps with 'Unknown'. Use the non-na values for each field for clustering and assign a '-1' to the NAs. Convert then to factor features\nbeer$MashAmount <- as.numeric(sapply(beer$MashAmount, function(x) gsub('l', '',x)))\ncl <- c()\nfor (k in 1:(length(unique(beer$MashAmount))-1)) {\n  cl[k] <- sum(kmeans(beer$MashAmount[!is.na(beer$MashAmount )], k)$withinss)\n}\nplot(cl, type = 'l')\n# 3 clusters looks good\nbeer$MashAmountClust <- -1 \nbeer$MashAmountClust[!is.na(beer$MashAmount )] <- \n  kmeans(beer$MashAmount[!is.na(beer$MashAmount )], 3)$clust \nbeer$MashAmountClust <- as.factor(beer$MashAmountClust)\n\n# MashTime\ncl <- c()\nfor (k in 1:(length(unique(beer$MashTime))-1)) {\n  cl[k] <- sum(kmeans(beer$MashTime[!is.na(beer$MashTime )], k)$withinss)\n}\nplot(cl, type = 'l')\n# 2 clusters\n\nbeer$MashTimeClust <- -1 \nbeer$MashTimeClust[!is.na(beer$MashTime )] <- \n  kmeans(beer$MashTime[!is.na(beer$MashTime )], 2)$clust \nbeer$MashTimeClust <- as.factor(beer$MashTimeClust)\n\n\n# MashTemp\ncl <- c()\nfor (k in 1:(length(unique(beer$MashTemp))-1)) {\n  cl[k] <- sum(kmeans(beer$MashTemp[!is.na(beer$MashTemp )], k)$withinss)\n}\nplot(cl, type = 'l')\n# 3 clusters\n\nbeer$MashTempClust <- -1 \nbeer$MashTempClust[!is.na(beer$MashTemp )] <- \n  kmeans(beer$MashTemp[!is.na(beer$MashTemp )], 3)$clust \nbeer$MashTempClust <- as.factor(beer$MashTempClust)\n\n# Yeast. Fermentis / Safale seems to be a good classifier for this field. I can't see how the other information in this field can be useful for now\nbeer$YeastFermentis <- \n  sapply(beer$Yeast, function(x) gregexpr('Fermentis / Safale', x)) != -1\n\n# YeastAttenuation can just be converted to a numerical value\nbeer$YeastAttenuation <- \n  sapply(beer$YeastAttenuation, function(x) as.numeric(gsub('%', '', x)))\n\n# YeastTemp is a range. Going to split it into the min and max values\nbeer$YeastTempMin <- \n  unlist(lapply(strsplit(as.character(beer$YeastTemp), '-'), \n                function(x) min(as.numeric(x))))\nbeer$YeastTempMax <- \n  unlist(lapply(strsplit(as.character(beer$YeastTemp), '-'), \n                function(x) max(as.numeric(x))))\n\n",
    "created" : 1457939658990.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2067739008",
    "id" : "DA689D54",
    "lastKnownWriteTime" : 1458029773,
    "last_content_update" : 1458029773557,
    "path" : "C:/Github/DP/beer_data_prep.R",
    "project_path" : "beer_data_prep.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}